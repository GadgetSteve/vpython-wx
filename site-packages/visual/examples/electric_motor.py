#!/usr/bin/env python
#coding:utf-8
"""
Electric Motor Demo

Click to pause or restart.
"""
from __future__ import print_function, division
#from visual import *
import visual as vp
# Kadir Haldenbilen, February 2011
PI = vp.pi

print (__doc__)

vp.scene.autocenter = True
vp.scene.width = 1024
vp.scene.height = 768

MOTOR_FRAME = vp.frame(axis=(0, 0, 1))  # Motor Frame
ROTOR_FRAME = vp.frame(frame=MOTOR_FRAME)                    # Rotor Frame

# Create contactor
# First, draw the outer circle
G1 = vp.shapes.circle(radius=1.2)
NS = 24
# We will have 24 contactor surfaces, 2 per each rotor wiring
for i in range(NS):
    # Second, subtract rectangular pieces to get a slice for each contact surface
    t = vp.shapes.rectangle(pos=(1.2*vp.cos(i*2*PI/NS), 1.2*vp.sin(i*2*PI/NS)),
                            width=2.1, height=0.05, rotate=i*2*PI/NS)
    G1 = G1 - t

G1 = G1 - vp.shapes.circle(radius=0.5)     # Last, subtract rotor shaft
C1 = 2.0
# Now, extrude to get "cylindrical" contactor surfaces
GE1 = vp.extrusion(pos=[(0, 0, 0), (0, 0, C1)], shape=G1, color=(1, 0.5, 0.3),
                   material=vp.materials.rough, frame=ROTOR_FRAME)

# Create contactor soldering tips, same as above
G2 = vp.shapes.circle(radius=1.4)
NS = 24
SPHS = []
for i in range(NS):
    t = vp.shapes.rectangle(pos=(1.2*vp.cos(i*2*PI/NS), 1.2*vp.sin(i*2*PI/NS)),
                            width=2.1, height=0.2, rotate=i*2*PI/NS)
    G2 = G2 - t
    sldr = vp.sphere(
        frame=ROTOR_FRAME,
        pos=(1.195*vp.cos(i*2*PI/NS+PI/NS), 1.195*vp.sin(i*2*PI/NS+PI/NS), 2.2),
        radius=0.1, material=vp.materials.shiny)     # add solders
    SPHS.append(sldr)

G2 = G2 - vp.shapes.circle(radius=0.6)     # Subtract a wider circle to enable soldering

# Finally extrude to get soldering surfaces
GE2 = vp.extrusion(pos=[(0, 0, 2), (0, 0, 2.4)], shape=G2, color=(1, 0.5, 0.3),
                   material=vp.materials.rough, frame=ROTOR_FRAME)

# Add shaft insulator material
# Define a circular ring of thickness=0.05
SC = vp.shapes.circle(radius=0.5, thickness=0.05)
# Extrude the ring to get a thin hollow cylinder insulator over the shaft
SCE = vp.extrusion(pos=[(0, 0, -0.5), (0, 0, 9.5)], shape=SC, color=(1, 0, 0),
                   material=vp.materials.plastic, frame=ROTOR_FRAME)

# The Rotor Shaft, defined by a simple cylinder
SHAFT = vp.cylinder(frame=ROTOR_FRAME, pos=(0, 0, -1.5), axis=(0, 0, 12), radius=0.495,
                    material=vp.materials.blazed)
# Add a piece of gear at one end of the shaft
# Use the gear shape to define the shape, note radius, addendum, dedendum sizes
GR = vp.shapes.gear(n=9, radius=0.455, addendum=0.04, dedendum=0.06, fradius=0.01)
# Extrude the gear shape appending it to the shaft end
GRE = vp.extrusion(frame=ROTOR_FRAME, pos=[(0, 0, -1.5), (0, 0, -3)], shape=GR,
                   material=vp.materials.blazed)

# Define Rotor Core
# Normally the core should have been built of many very thin sheets
# For performance reasons, a single block is built
# First define the outer circle
G3 = vp.shapes.circle(radius=3.0)

NS = 12
# We will have 12 wiring sections on the rotor core
for i in range(NS):
    # First define the vertical channels
    T1 = vp.shapes.rectangle(pos=(3*vp.cos(i*2*PI/NS), 3*vp.sin(i*2*PI/NS)),
                             width=1.1, height=0.3, rotate=i*2*PI/NS)
    # Then define winding hollow as a trapezoidal area
    T2 = vp.shapes.trapezoid(pos=(2.*vp.cos(i*2*PI/NS), 2.*vp.sin(i*2*PI/NS)),
                             width=1.2, top=0.5, height=1.4, roundness=0.1,
                             rotate=i*2*PI/NS+PI/2, )
    G3 = G3 - T2 - T1   # From the circle, subtract wiring areas

# Obtain rotor core profile
G3 = G3 - vp.shapes.circle(radius=0.495)       # Subtract rotor shaft area

# Define rotor core body sizes
PS = 5.5
DLT = 0.05
THK = 5.04
nl = 1      # nl = 100
CF = vp.frame(frame=ROTOR_FRAME, pos=(0, 0, THK/2.+C1/2.0))
for i in range(nl):
    # Extrude rotor core profile to get the full core body
    GE3 = vp.extrusion(pos=[(0, 0, i*DLT), (0, 0, i*DLT+THK)], shape=G3,
                       color=(0.7, 0.7, 0.705), twist=0.0, frame=CF)

# Do the core wire windings
# Here is a trick to build a saw-teeth profile, to represent many single windings
N = 20 # coils
VRIGHT = vp.vector(.3, 1.3)
R = vp.mag(VRIGHT)/(2*N)
VRIGHT = vp.norm(VRIGHT)
# S is the cross sectional profile of "winding block"
S = vp.Polygon([(-.1, -.65), (0, -.65), (.3, .65), (-.1, .65)])
for n in range(N):
    RIGHT = vp.vector(0, -.65)+(R+n*2*R)*VRIGHT
    # Add saw-teeth on the block to represent wires
    S += vp.shapes.circle(pos=(RIGHT.x, RIGHT.y), radius=R, np=4)

# Define the winding path as a rounded rectangle
P = vp.shapes.rectangle(width=.5, height=THK)
P += vp.shapes.circle(pos=(0, -THK/2), radius=.25, np=10)
P += vp.shapes.circle(pos=(0, +THK/2), radius=.25, np=10)
WRFS = []
for i in range(NS):
    # We need a separate frame for individiual winding section
    WRF = vp.frame(frame=CF, pos=(0, 2, THK/2.))
    WRFS.append(WRF)
    # Extrude the winding block per winding path
    wre = vp.extrusion(frame=WRF, pos=P, shape=S,
                       color=(.7, .5, .15), material=vp.materials.rough)
    # Make angular corrections to position on the rotor core
    WRF.rotate(axis=(0, 0, 1), angle=(i*2*PI/NS+PI/NS), origin=(0, 0, 0))

# Connect contactor surfaces to windings with cables
for i in range(NS):
    # Connect every other contactor to one end of windings (somewhere!)
    vp.curve(frame=ROTOR_FRAME, pos=[SPHS[i*2].pos, CF.pos+WRFS[i].pos], radius=0.05,
             color=(0.4, 0.2, 0))
    # Connect remaining ones to the other end of windings (somewhere!)
    vp.curve(frame=ROTOR_FRAME, pos=[SPHS[i*2+1].pos, CF.pos+WRFS[i].pos], radius=0.05,
             color=(0, 0, 1))

# Create Brushes
# From a rectangular cross section, subtract rotor contactor circle, leaving us two
# brushes on each sides of the contactor, with circular profile
BR = vp.shapes.rectangle(width=5, height=0.4) - vp.shapes.circle(radius=1.21)
# Extrude the brush profile to get the brushes in 3D
BRE = vp.extrusion(frame=MOTOR_FRAME, pos=[(0, 0, 0.4), (0, 0, 1.6)], color=(0.1, 0.1, 0.15),
                   material=vp.materials.rough, shape=BR)

# Create Brush Housings
# Define a rectangular frame, with a thickness of 0.1
BH = vp.shapes.rectangle(width=1.3, height=0.5, thickness=0.1)
# Extrude the rectangular frame to obtain hollow boxes for each housing
BHE1 = vp.extrusion(frame=MOTOR_FRAME, pos=[(1.4, 0, 1), (2.9, 0, 1)],
                    shape=BH, color=(0.9, 1, 0.8),
                    material=vp.materials.rough)
BHE2 = vp.extrusion(frame=MOTOR_FRAME, pos=[(-1.4, 0, 1), (-2.9, 0, 1)], shape=BH,
                    color=(0.9, 1, 0.8),
                    material=vp.materials.rough)

# Place a screw on each housing to fix the power cables
# Create a screw head profile by subtracting a cross from a circle
SCRH = vp.shapes.circle(radius=1) - vp.shapes.cross()
SCRH.scale(0.15, 0.15)
# Extrude a little to get the screw head
SCRHW1 = vp.extrusion(frame=MOTOR_FRAME, pos=[(2.7, 0.2, 1), (2.7, 0.3, 1)],
                      shape=SCRH, color=(1, 1, 0.8),
                      material=vp.materials.rough)
SCRHW2 = vp.extrusion(frame=MOTOR_FRAME, pos=[(-2.7, 0.2, 1), (-2.7, 0.3, 1)],
                      shape=SCRH, color=(1, 1, 0.8),
                      material=vp.materials.rough)

# Create the screw bodies
# Use a square to create the body with teeth
SCRB = vp.shapes.rectangle(scale=0.1)
# Extrude the square with twist parameter to get the teeth of the screw
SCRBE1 = vp.extrusion(frame=MOTOR_FRAME, pos=vp.paths.line(
    start=(2.7, 0.2, 1), end=(2.7, -0.3, 1), np=20),
                      shape=SCRB, twist=0.4, color=(1, 1, 0.9),
                      material=vp.materials.rough)
SCRBE2 = vp.extrusion(frame=MOTOR_FRAME, pos=vp.paths.line(
    start=(-2.7, 0.2, 1), end=(-2.7, -0.3, 1), np=20),
                      shape=SCRB, twist=0.4, color=(1, 1, 0.9),
                      material=vp.materials.rough)

# Place the brush system on a craddle
# Use a rectangular block, subtract rotor circle to allow space for the rotor
CRDL = (
    vp.shapes.rectangle(pos=(0, -0.9), width=5.8, height=1.4) -
    vp.shapes.circle(radius=1.21) - vp.shapes.circle(pos=(-2.2, -0.9),
                                                     radius=0.1))
# Extrude the block to get the craddle
CRDLE = vp.extrusion(frame=MOTOR_FRAME, pos=[(0, -0.05, 0.2), (0, -0.05, 1.8)],
                     material=vp.materials.plastic, shape=CRDL)

# Connect power cables to the brushes
# Use simple curves to define cables
cbl1i = vp.curve(frame=MOTOR_FRAME, pos=[SCRHW1.pos[-2], SCRHW1.pos[-2]- vp.vector(-2, 0, 0)],
                 radius=0.03, color=GE1.color)
cbl1o = vp.curve(frame=MOTOR_FRAME, pos=[SCRHW1.pos[-2], SCRHW1.pos[-2]- vp.vector(-1.5, 0, 0)],
                 radius=0.05, color=(0, 0, 1))

cbl2i = vp.curve(frame=MOTOR_FRAME, pos=[SCRHW2.pos[-2], SCRHW2.pos[-2]+ vp.vector(-0.5, 0, 0)],
                 radius=0.03, color=GE1.color)
cbl2i.append(pos=cbl2i.pos[-1]+(0, -2, 0))
cbl2i.append(pos=cbl2i.pos[-1]+(7, 0, 0))
cbl2o = vp.curve(frame=MOTOR_FRAME, pos=cbl2i.pos, radius=0.05, color=(1, 0, 0))
cbl2o.pos[-1] -= (0.5, 0, 0)

# Add ball-bearings at both ends of the shaft
# First create the cross section of the bearing
# From a rectangular shape subtract the circles for the balls, and then
# subtract another rectangle for the shaft
BR = vp.shapes.rectangle(
    width=0.54, height=0.75) - vp.shapes.circle(
        radius=0.25) - vp.shapes.rectangle(width=0.30, height=0.76)
B1F = vp.frame(frame=ROTOR_FRAME, pos=(0, 0, -0.75))
# Extrude the cross section along a full circle to get a ball bearing
BR1 = vp.extrusion(frame=B1F, pos=vp.paths.circle(radius=0.75), shape=BR,
                   material=vp.materials.blazed)
B1F.rotate(angle=PI/2)
B2F = vp.frame(frame=ROTOR_FRAME, pos=(0, 0, 10.))
BR2 = vp.extrusion(frame=B2F, pos=vp.paths.circle(radius=0.75), shape=BR,
                   material=vp.materials.blazed)
B2F.rotate(angle=PI/2)

# Do not forget to add the balls
BBRS1 = []
BBRS2 = []
for i in range(7):
    BBRS1.append(vp.sphere(
        frame=ROTOR_FRAME,
        pos=(0.75*vp.cos(i*2*PI/7.0), 0.75*vp.sin(i*2*PI/7.0), -0.75),
        radius=0.25, material=vp.materials.rough))
    BBRS2.append(
        vp.sphere(
            frame=ROTOR_FRAME, pos=(
                0.75*vp.cos(i*2*PI/7.0), 0.75*vp.sin(i*2*PI/7.0), 10.),
            radius=0.25, material=vp.materials.rough))

# Define the stator core - again defined as a single block
# We did not include all stator parts here for better visualisation
# Use a rounded rectangle for the stator base.
# Subtract a large circle in the middle to allow for the rotor
# Subtract circular holes to place the stator windings
# Subtract some more holes for fixing the stator core on the motor body
stb = (vp.shapes.rectangle(pos=(0, -2.25), width=6, height=3, roundness=0.5) -
       vp.shapes.rectangle(width=8.5, height=4.6) - vp.shapes.circle(radius=3.1) -
       vp.shapes.circle(pos=(2.6, -2.1), radius=0.3) -
       vp.shapes.circle(pos=(2.0, -3.4), radius=0.15) -
       vp.shapes.circle(pos=(-2.6, -2.1), radius=0.3) -
       vp.shapes.circle(pos=(-2.0, -3.4), radius=0.15))

# Extrude the stator profile to get the stator core
stbe = vp.extrusion(
    frame=MOTOR_FRAME, pos=[(0, 0, THK/2.+C1/2.0), (0, 0, THK/2.+C1/2.0+THK)],
    shape=stb)


# Here is a complex path definition for stator winding, which is not planar.
# The path is made up of an arc in YZ + line in ZX + arc in ZY + line in XZ

tp = []
# Define the arc path
pp = vp.shapes.arc(angle1=-PI/3.5, angle2=PI/3.5, radius=3.4)
cp = pp.contour(0)[0:len(pp.contour(0))//2]
for p in cp:
    tp.append((0, -p[0], p[1]))
# Create the reverse arc path
tmp = []
tmp.extend(tp)
tmp.reverse()
tp.append(vp.vector(tp[-1])-vp.vector(THK+0.7, 0, 0))
for p in tmp:
    # We are in 3D, not in 2D
    tp.append(vp.vector(p)-vp.vector(THK+0.7, 0, 0))
tp.append(vp.vector(tp[-1])+vp.vector(THK+0.7, 0, 0))
# Just a simple winding cross section for the whole of the stator winding
sts = vp.shapes.circle(radius=0.3)
sfrm = vp.frame(frame=MOTOR_FRAME, pos=(0, 0, THK+C1*2-0.15))
# Extrude the winding profile along the complex stator path
stse = vp.extrusion(frame=sfrm, pos=tp,
                    shape=sts, color=(1, 0, 0))
sfrm.rotate(axis=(0, 1, 0), angle=-PI/2)

# Create the motor cover as a rotational extrusion along the mootor
# Add two rounded rectangles which will cover all the rotor and stator.
# Leave the tips of shaft outside the cover
cvr = (vp.shapes.rectangle(width=3, height=11.4, roundness=0.1) +
       vp.shapes.rectangle(width=9, height=10, roundness=0.1))
cvrc = vp.Polygon(cvr.contour(0))
# Create a scaled down copy of the same profile
cvrc.scale(0.95, 0.95)
# Subtract the smaller one to get a thin "skin" to represent the cover
# We do not need the full profile, take out the lower half, allowing some
# space for the ball bearings
cvr = (cvr - cvrc - vp.shapes.rectangle(width=1.8, height=12) -
       vp.shapes.rectangle(pos=(-4, 0), width=7, height=12))
cfrm = vp.frame(pos=(-4.6, 0, 0))
# Rotate the profile around the shaft along an arc to get the cover.
# Do not use full circle, so that we can see the inside of the motor
cvre = vp.extrusion(
    frame=cfrm,
    pos=vp.paths.arc(angle1=-PI/4, angle2=PI, radius=0.1),
    shape=cvr, color=(0, 0.6, 0.3), material=vp.materials.rough)
# Place the cover correctly
cfrm.rotate(angle=PI/2)
cfrm.rotate(axis=(0, 1, 0), angle=PI/2)
cfrm.rotate(axis=(1, 0, 0), angle=-PI/2)

# Connect power cables
angl = PI/400
RUN = True
# Turn on the motor
while True:
    vp.rate(100)
    if RUN:
        ROTOR_FRAME.rotate(angle=angl, axis=(0, 0, 1))
    if vp.scene.mouse.events:
        m = vp.scene.mouse.getevent()
        if m.click == 'left':
            RUN = not RUN

