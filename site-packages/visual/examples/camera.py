#!/usr/bin/env python
#coding:utf-8
"""
Simulation of the VPython camera geometry.
Version using wx widgets.  Geoff Tovey, England, 11 March 2014.

================================================================================
"""

from __future__ import division, print_function
import visual as vs   # for 3D panel
import wx   # for widgets

# Draw window & 3D pane =================================================

# make a main window. Also sets w.panel to addr of wx window object.
WIN = vs.window(width=1024, height=720, menus=False,
                title='SIMULATE VPYTHON GUI')
# make a 3D panel
SCENE = vs.display(window=WIN, width=830, height=690,
                   forward=-vs.vector(1, 1, 2))
CLR = vs.color
VSS = SCENE

# Draw 3D model ======================

def axes(frame, colour, size, posn):
    """Make axes visible (of world or frame)."""
    # Use None for world.
    directions = [
        vs.vector(size, 0, 0), vs.vector(0, size, 0), vs.vector(0, 0, size)]
    texts = ["X", "Y", "Z"]
    posn = vs.vector(posn)
    for i in range(3): # EACH DIRECTION
        vs.curve(frame=frame, color=colour, pos=[posn, posn+directions[i]])
        vs.label(frame=frame, color=colour, text=texts[i],
                 pos=posn + directions[i], opacity=0, box=False)

axes(None, CLR.white, 3, (-11, 6, 0))


def draw_grid(posn=(0, 0, 0), sq_len=1, height=5, width=8, normal='z', colour=CLR.white):
    """ Draw grid of squares in XY, XZ or YZ plane with corner nearest origin at given posn.
    sq_len=length of side of square. height=number of squares high (Y).
    W=number of squares wide (X). normal=the axis which is normal to the grid plane.
    """
    _ht = height*sq_len
    _wd = width*sq_len
    for i in range(0, _wd+1, sq_len):  # FOR EACH VERTICAL LINE
        if   normal == 'z':
            vs.curve(pos=[
                (posn[0]+i, posn[1]+_ht, posn[2]),
                (posn[0]+i, posn[1], posn[2])], color=colour)
        elif normal == 'x':
            vs.curve(pos=[
                (posn[0], posn[1]+_ht, posn[2]+i),
                (posn[0], posn[1], posn[2]+i)], color=colour)
        else:
            vs.curve(pos=[(posn[0]+i, posn[1], posn[2]+_ht),
                          (posn[0]+i, posn[1], posn[2])], color=colour)
    for i in range(0, _ht+1, sq_len):  # FOR EACH HORIZONTAL LINE
        if normal == 'z':
            vs.curve(pos=[(posn[0], posn[1]+i, posn[2]),
                          (posn[0]+_wd, posn[1]+i, posn[2])], color=colour)
        elif normal == 'x':
            vs.curve(pos=[(posn[0], posn[1]+i, posn[2]+_wd),
                          (posn[0], posn[1]+i, posn[2])], color=colour)
        else:
            vs.curve(pos=[(posn[0], posn[1], posn[2]+i),
                          (posn[0]+_wd, posn[1], posn[2]+i)], color=colour)

draw_grid(normal='z', posn=(-6, 0, -6), colour=CLR.blue, width=12)
draw_grid(normal='z', posn=(-6, 0, 6), colour=CLR.blue, width=5)
draw_grid(normal='z', posn=(1, 0, 6), colour=CLR.blue, width=5)
draw_grid(normal='x', posn=(-6, 0, -6), colour=CLR.green, width=12)
draw_grid(normal='x', posn=(6, 0, -6), colour=CLR.green, width=12)
draw_grid(normal='y', posn=(-6, 0, -6), colour=CLR.orange, width=12, height=12)
draw_grid(normal='z', posn=(-6, 0, 0), colour=CLR.red, width=12)

# The central post. Base of post is the origin. ***************
POLE = vs.cylinder(pos=(0, 0, 0), axis=(0, 3, 0), radius=0.1, color=(1, 0, 0))

SCENE_SIZE = 12 # approx size of model drawn above.

def draw_line(posn, length, direction):
    """draw straight line STARTING at given posn, with given
    length and direction.  ALL ARE RELATIVE TO CAMERA FRAME"""
    return vs.curve(frame=CAM_FRAME, pos=[posn, posn+direction.norm()*length])

def redraw_line(line, posn, length, direction):
    """ Re-Draw the line."""
    line.pos = [posn, posn+direction.norm()*length]

# These should be defined at global scope even though created elsewhere
CAM_BOX, CENT_PLANE, CAM_LAB = None, None, None
CAN_TRI, RANGE_LAB, LINELEN = None, None, None
FWR_ARROW, MOUSE_LINE, MOUSE_ARROW = None, None, None
MOUSE_LAB, FOV, RANGE_X = None, None, None
CAM_FRAME, RAY, FWD_LINE = None, None, None
CAM_DIST = None

def draw_camera_frame():
    """Create frame and draw its contents."""
    global  CAM_BOX, CENT_PLANE, CAM_LAB, CAN_TRI, RANGE_LAB, LINELEN, FWD_LINE
    global FWR_ARROW, MOUSE_LINE, MOUSE_ARROW, MOUSE_LAB, FOV, RANGE_X, CAM_DIST, CAM_FRAME
    global RAY
    CAM_FRAME = vs.frame(pos=vs.vector(0, 2, 2, ), axis=(0, 0, 1))
               # NB: contents are rel to this frame.  start with camera looking "forward"
               # origin is at simulated scene.center
    FOV = vs.pi/3.0  # 60 deg
    RANGE_X = 6  # simulates scene.range.x
    CAM_DIST = RANGE_X / vs.tan(FOV/2.0)  # distance between camera and center.
    RAY = vs.vector(-20.0, 2.5, 3.0).norm()  # (unit) direction of ray vector (arbitrary)
                                         #  REL TO CAMERA FRAME
    CAM_BOX = vs.box(frame=CAM_FRAME, length=1.5, height=1, width=1.0,
                     color=CLR.blue, pos=(CAM_DIST, 0, 0)) # camera-box
    CENT_PLANE = vs.box(frame=CAM_FRAME, length=0.01, height=RANGE_X*1.3,
                        width=RANGE_X*2, pos=(0, 0, 0), opacity=0.5)  # central plane
    CAM_LAB = vs.label(frame=CAM_FRAME, text='U', pos=(CAM_DIST, 0, 0),
                       height=9, xoffset=6)
    CAN_TRI = vs.faces(frame=CAM_FRAME, pos=[
        (0, 0, 0), (0, 0, -RANGE_X), (CAM_DIST, 0, 0)])
    CAN_TRI.make_normals()
    CAN_TRI.make_twosided()
    RANGE_LAB = vs.label(frame=CAM_FRAME, text='R', pos=(0, 0, -RANGE_X),
                         height=9, xoffset=6)
    LINELEN = SCENE_SIZE + vs.mag(
        CAM_FRAME.axis.norm()*CAM_DIST + CAM_FRAME.pos)  # len of lines from camera

    FWD_LINE = draw_line(vs.vector(CAM_DIST, 0, 0), LINELEN, vs.vector(-1, 0, 0))
    FWR_ARROW = vs.arrow(frame=CAM_FRAME, axis=(-2, 0, 0), pos=(CAM_DIST, 0, 0),
                         shaftwidth=0.08, color=CLR.yellow)
    vs.label(frame=CAM_FRAME, text='C', pos=(0, 0, 0), height=9, xoffset=6,
             color=CLR.yellow)
    MOUSE_LINE = draw_line(vs.vector(CAM_DIST, 0, 0), LINELEN, RAY)
    MOUSE_ARROW = vs.arrow(frame=CAM_FRAME, axis=RAY*2, pos=(CAM_DIST, 0, 0),
                           shaftwidth=0.08, color=CLR.red)
    MOUSE_LAB = vs.label(
        frame=CAM_FRAME, text='M', height=9, xoffset=10,
        color=CLR.red,
        pos=-RAY*(CAM_DIST/vs.dot(RAY, (1, 0, 0))) + (CAM_DIST, 0, 0))

draw_camera_frame()
# axes( cam_frame, clr.red, 3, (11, 6, 0)) # testing ###########

############## cam_frame.pos       simulates scene.center     ################
############## - cam_frame.axis    simulates scene.forward    ################
############## range_x             simulates scene.range.x    ################
############## fov                 simulates scene.fov        ################
#### ray converted to world coords simulates scene.mouse.ray  ################

#  Animation tools ==========================================

def redraw_lines():
    """ Re-Draw the lines."""
    global LINELEN
    LINELEN = SCENE_SIZE + vs.mag(CAM_FRAME.axis.norm()*CAM_DIST + CAM_FRAME.pos)
    redraw_line(FWD_LINE, vs.vector(CAM_DIST, 0, 0), LINELEN, vs.vector(-1, 0, 0))
    redraw_line(MOUSE_LINE, vs.vector(CAM_DIST, 0, 0), LINELEN, RAY)

def redraw_tri():
    """ Redraw the camera triangle."""
    #global cam_tri, range_x, cam_dist
    CAN_TRI.pos = [(0, 0, 0), (0, 0, -RANGE_X), (CAM_DIST, 0, 0)]
    CAN_TRI.make_normals()
    CAN_TRI.make_twosided()


# Event handlers =========================
SAVED_PYVARS = []

def set_mod_view():
    """ Set so that we see view from mod-cam."""
    global SAVED_PYVARS
    VSS.userspin = VSS.userzoom = False
    VSS.autoscale = VSS.autocenter = False  # should not be necessary,  but is!
    SAVED_PYVARS = [tuple(VSS.forward), tuple(VSS.center), VSS.fov]
    # save VPython GUI status (so that we can restore it later ). tuple()is NEEDED so the data
    # is copied - not just its address.   vss.range is not useful.
    VSS.forward = - CAM_FRAME.axis
    VSS.center = CAM_FRAME.pos
    VSS.fov = FOV
    VSS.range = RANGE_X
    CAM_BOX.visible = FWR_ARROW.visible = MOUSE_ARROW.visible = False
    CAN_TRI.visible = False

def set_py_view():
    """ Set so we see view from py-cam (i.e. std VPython)."""
    VSS.userspin = VSS.userzoom = True
    VSS.forward, VSS.center, VSS.fov = SAVED_PYVARS
                                    # Restore py-vars to what they were when qPy was turned off.
                                    # Except RANGE - as cannot be saved.  So....
    VSS.range = SCENE_SIZE*1.5   # SET it.
    CAM_BOX.visible = FWR_ARROW.visible = MOUSE_ARROW.visible = True
    CAN_TRI.visible = True


def h_camera(dummy_evt):
    """ re "Switch Camera" button."""
    global Q_PY
    if Q_PY:  # we are seeing view from py-cam
        Q_PY = False
        set_mod_view()  # set so that we see view from mod-cam
    else:
        Q_PY = True
        set_py_view()  # set so we see view from py-cam (ie std VPython)

def h_reset(dummy_evt):
    """ re "Reset" button."""
    global CAM_FRAME
    CAM_BOX.visible = FWR_ARROW.visible = MOUSE_ARROW.visible = True
    CAN_TRI.visible = True  # so is included in cam_frame.objects list.
    for obj in CAM_FRAME.objects:
        obj.visible = False
        del obj
    del CAM_FRAME
    draw_camera_frame()  # recreate camera frame and its contents
    MODE_LAB.SetLabel("")  # as is no longer right
    if not Q_PY:
        set_mod_view() # because drawCameraFrame() assumes qPy is True.

def h_radio(dummy_evt):
    """ re radio button."""
    global MODE
    MODE = ['c', 'f', 'r', 'v', 'm', None][BRADIO.GetSelection()]
    if MODE == None:
        MODE_LAB.SetLabel('')

def h_help(dummy_evt):
    """ re "HELP" button."""
    wx.MessageBox(
"""The BLUE BOX (at U) represents the camera - ie your viewpoint in the model.
The WHITE rectangle represents the VPython window on your display device.
      On that: C marks its centre (held as scene.center)
                    R marks the midpoint of the right-hand edge, and
                    M marks the mouse position (held as scene.mouse.pos, READ ONLY).
The YELLOW ARROW marks the scene.forward (unit) vector.
The RED ARROW marks the scene.mouse.ray (unit) vector.  It is READ ONLY.
The right-angled triangle U-C-R shows the relationship between the main scene attributes:
      The shape is determined by the angle at U - which is held as scene.fov/2.
      The size is determined by the length C-R - which is held as scene.range.x
      The position is determined by the position of C - which is held as scene.center.
      The orientation is determined by the direction U-C - which is held as scene.forward.

The camera position is also held (as scene.mouse.camera) - but is READ ONLY.
In this simulation scene.range is the same on all 3 axes.

The control panel lets you see the effect of altering each of the above scene attributes.
The "Switch camera" button shows you the view from the camera in the model. It toggles.
The "Reset model" button resets the model to its initial state.  It does not alter your view.

Zooming is similar to altering scene.range but does not alter scene.range.
Spinning is similar to altering scene.forward.
""", 'HELP', wx.OK)

def h_mousedown():
    """handle mouse-DOWN event"""
    global Q_DRAGGING, MOUSE_POS_OLD
    VSS.unbind('mousedown', h_mousedown) # STOP monitoring for mouse-down
    Q_DRAGGING = True
    MOUSE_POS_OLD = VSS.mouse.pos  # forget old position of mouse.
    VSS.bind('mouseup', h_mouseup)  # START monitoring for mouse-up

VSS.bind('mousedown', h_mousedown) # START monitoring for mouse-down

def h_mouseup():
    """ handle mouse-UP event"""
    global Q_DRAGGING
    VSS.unbind('mouseup', h_mouseup)  # STOP monitoring for mouse-up
    Q_DRAGGING = False
    VSS.bind('mousedown', h_mousedown) # START monitoring for mouse-down

# Draw widgets ==========================

X1 = SCENE.width + 5
PAN = WIN.panel   # addr of wx window object
PAN.SetSize((1024, 720)) # work-around to make display work.  >= size of client area of window.

# Controls (= widgets) have to be put in the wx window.
# Positions and sizes are in pixels, and pos(0,0) is the upper left corner of the window.

wx.StaticText(PAN, pos=(X1, 10),
              label="Select an item, then\nleft-drag the mouse over\n"
              "the model to see the\neffect of altering that:")

BRADIO = wx.RadioBox(PAN, pos=(X1, 90),
                     choices=['scene.center', 'scene.forward', 'scene.range',
                              'scene.fov', 'moving the mouse', 'NONE OF THOSE'],
                     style=wx.RA_VERTICAL)

BRADIO.SetSelection(5)   # Set NONE as intially selected.

BRADIO.Bind(wx.EVT_RADIOBOX, h_radio)
MODE_LAB = wx.StaticText(PAN, pos=(X1, 310))

def str2(item):
    """ convert tuple or vector to char values with 2 sig figs.
        i.e. is like str() but shows only 2 sig figs."""
    res = ''
    for i in item:
        res += format(i, " 9.2")
        # Means output has: pad LHS with spaces, width 9, 2 sig figs.
    return res

def button1(label, y_val, func):
    """ Create a button with a label & y_pos."""
    _bb = wx.Button(PAN, label=label, pos=(X1+5, y_val), size=(150, 40))
    _bb.Bind(wx.EVT_BUTTON, func)

button1('HELP', 500, h_help)
button1('Switch Camera', 550, h_camera)
button1('Reset model', 600, h_reset)

# Capture events  =========================================

MODE = None
Q_DRAGGING = False
Q_PY = True # we see view from std VPython camera
MOUSE_POS_OLD = VSS.mouse.pos
VSS.autoscale = False
VSS.autocenter = False

while True:
    vs.rate(20)
    if not Q_DRAGGING:
        continue  # only simulate changes if left button is down
    if VSS.mouse.pos == MOUSE_POS_OLD:
        continue
    MOUSE_CHANGE = (VSS.mouse.pos - MOUSE_POS_OLD)
    MOUSE_POS_OLD = VSS.mouse.pos

    if MODE == 'c':  # demonstrate altering scene.center
        MOUSE_CHANGE.z = MOUSE_CHANGE.x  # improve variation
        CAM_FRAME.pos = CAM_FRAME.pos + MOUSE_CHANGE/1.5
        redraw_lines()
        MODE_LAB.SetLabel('scene.center:\n' + str2(CAM_FRAME.pos))
        if not Q_PY:
            VSS.center = CAM_FRAME.pos

    elif MODE == 'f': # demonstrate altering scene.forward vector
        CAM_FRAME.axis = (CAM_FRAME.axis + MOUSE_CHANGE/12.0).norm()
        CAM_FRAME.up = (0, 1, 0)
        MODE_LAB.SetLabel('scene.forward:\n' + str2(-CAM_FRAME.axis))
        if not Q_PY:
            VSS.forward = - CAM_FRAME.axis

    elif MODE == 'r': # demonstrate altering scene.range.  Alters size of camera triangle.
        if Q_PY:
            GEARING = 4
        else:
            GEARING = 1
        CAM_DIST = CAM_DIST + (MOUSE_CHANGE.x + MOUSE_CHANGE.y + MOUSE_CHANGE.z)*GEARING
        if CAM_DIST <= 0:
            CAM_DIST = 0.001  # allow only positive
        LIMIT = SCENE_SIZE*2
        if CAM_DIST > LIMIT:
            CAM_DIST = LIMIT # limit size
        redraw_lines()
        CAM_BOX.pos = (CAM_DIST, 0, 0)
        CAM_LAB.pos = (CAM_DIST, 0, 0)
        FWR_ARROW.pos = (CAM_DIST, 0, 0)
        MOUSE_ARROW.pos = (CAM_DIST, 0, 0)
        MOUSE_LAB.pos = -RAY*(CAM_DIST/vs.dot(RAY, (1, 0, 0))) + (CAM_DIST, 0, 0)
        RANGE_X = CAM_DIST * vs.tan(FOV/2.0)
        CENT_PLANE.width = RANGE_X*2
        CENT_PLANE.height = RANGE_X*4.0/3
        redraw_tri()  # redraw the camera triangle
        RANGE_LAB.pos = (0, 0, -RANGE_X)
        MODE_LAB.SetLabel('scene.range:\n' + format(RANGE_X, "9.3"))
        if not Q_PY:
            VSS.range = RANGE_X

    elif MODE == 'v': # demonstrate altering scene.fov
        CAM_DIST = CAM_DIST + (MOUSE_CHANGE.x + MOUSE_CHANGE.y + MOUSE_CHANGE.z)*4
        if CAM_DIST <= 0:
            CAM_DIST = 0.001  # allow only positive
        RAY = (MOUSE_LAB.pos - (CAM_DIST, 0, 0)).norm()
        redraw_lines()
        CAM_BOX.pos = (CAM_DIST, 0, 0)
        CAM_LAB.pos = (CAM_DIST, 0, 0)
        FWR_ARROW.pos = (CAM_DIST, 0, 0)
        MOUSE_ARROW.pos = (CAM_DIST, 0, 0)
        MOUSE_ARROW.axis = RAY*2
        redraw_tri()  # redraw the camera triangle
        FOV = 2*vs.arctan(RANGE_X / CAM_DIST)
        MODE_LAB.SetLabel('scene.fov:\n{0:9.0f} deg'.format(vs.degrees(FOV)))
        if not Q_PY:
            VSS.fov = FOV

    elif MODE == 'm': # demonstrate moving the mouse.
        HIT = VSS.mouse.project(CAM_FRAME.axis, CAM_FRAME.pos)
        M_POS = CAM_FRAME.world_to_frame(HIT)
        if abs(M_POS.z) <= CENT_PLANE.width/2.0 and \
           abs(M_POS.y) <= CENT_PLANE.height/2.0:   # not "off the screen"
            RAY = (M_POS - (CAM_DIST, 0, 0)).norm()
            redraw_line(MOUSE_LINE, vs.vector(CAM_DIST, 0, 0), LINELEN, RAY)
            MOUSE_LAB.pos = M_POS
            MOUSE_ARROW.axis = 2*RAY
            RAYOUT = CAM_FRAME.frame_to_world(RAY) - CAM_FRAME.frame_to_world((0, 0, 0))
            MODE_LAB.SetLabel('scene.mouse.ray:\n' + str2(RAYOUT))
